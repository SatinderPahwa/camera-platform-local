{% extends "base.html" %}

{% block content %}
<!-- Livestream Video Player -->
<div class="row">
    <div class="col-12">
        <div class="card shadow-sm">
            <div class="card-body p-0">
                <div id="videoContainer" style="position: relative; background: #000; display: flex; align-items: center; justify-content: center; min-height: 60vh; max-height: 85vh;">
                    <video id="videoPlayer" autoplay playsinline muted style="max-width: 100%; max-height: 85vh; width: auto; height: auto;"></video>
                    <div id="videoOverlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); color: #fff; font-size: 18px;">
                        <div class="text-center">
                            <i class="fas fa-video fa-3x mb-3"></i>
                            <p>Waiting to connect...</p>
                        </div>
                    </div>
                    <!-- Mute/Unmute Button -->
                    <button id="muteBtn" class="btn btn-dark btn-sm" style="position: absolute; top: 10px; left: 10px; opacity: 0.7; z-index: 10;" title="Unmute Audio">
                        <i class="fas fa-volume-mute"></i>
                    </button>
                    <!-- Fullscreen Button -->
                    <button id="fullscreenBtn" class="btn btn-dark btn-sm" style="position: absolute; top: 10px; right: 10px; opacity: 0.7; z-index: 10;" title="Fullscreen">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div>
            <div class="card-footer">
                <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div class="d-flex gap-2">
                        <button id="startStreamBtn" class="btn btn-success">
                            <i class="fas fa-play me-2"></i>Start Stream
                        </button>
                        <button id="stopStreamBtn" class="btn btn-danger" disabled>
                            <i class="fas fa-stop me-2"></i>Stop Stream
                        </button>
                        <button id="cleanSetupBtn" class="btn btn-warning" onclick="cleanStreamSetup()">
                            <i class="fas fa-broom me-2"></i>Clean Setup
                        </button>
                    </div>
                    <div class="d-flex gap-2 align-items-center">
                        <span class="badge bg-secondary">
                            <i class="fas fa-users me-1"></i>
                            <span id="viewerCount">0</span> viewers
                        </span>
                        <span id="streamStatus" class="badge bg-secondary">Disconnected</span>
                        <button class="btn btn-outline-secondary btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#debugPanel">
                            <i class="fas fa-bug me-1"></i>Debug
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Debug Panel (Collapsed by default) -->
<div class="row mt-3">
    <div class="col-12">
        <div class="collapse" id="debugPanel">
            <div class="card shadow-sm">
                <div class="card-header bg-dark text-white">
                    <i class="fas fa-bug me-2"></i>Debug Information
                </div>
                <div class="card-body">
                    <div class="row">
                        <!-- Camera Info -->
                        <div class="col-md-4">
                            <h6 class="text-muted mb-3">Connection</h6>
                            <table class="table table-sm table-borderless">
                                <tr>
                                    <td class="text-muted">Camera ID:</td>
                                    <td class="text-end"><code id="displayCameraId">-</code></td>
                                </tr>
                                <tr>
                                    <td class="text-muted">Stream ID:</td>
                                    <td class="text-end"><code id="displayStreamId">-</code></td>
                                </tr>
                                <tr>
                                    <td class="text-muted">Connection:</td>
                                    <td class="text-end"><span id="displayConnectionStatus" class="badge bg-secondary">-</span></td>
                                </tr>
                                <tr>
                                    <td class="text-muted">ICE State:</td>
                                    <td class="text-end"><span id="displayIceState" class="badge bg-secondary">-</span></td>
                                </tr>
                            </table>
                        </div>

                        <!-- Statistics -->
                        <div class="col-md-3">
                            <h6 class="text-muted mb-3">Statistics</h6>
                            <table class="table table-sm table-borderless">
                                <tr>
                                    <td class="text-muted">Duration:</td>
                                    <td class="text-end"><span id="statDuration">-</span></td>
                                </tr>
                                <tr>
                                    <td class="text-muted">Keepalives:</td>
                                    <td class="text-end"><span id="statKeepalives">-</span></td>
                                </tr>
                                <tr>
                                    <td class="text-muted">Errors:</td>
                                    <td class="text-end"><span id="statErrors">0</span></td>
                                </tr>
                            </table>
                        </div>

                        <!-- Activity Log -->
                        <div class="col-md-5">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="text-muted mb-0">Activity Log</h6>
                                <button id="clearLogBtn" class="btn btn-sm btn-outline-secondary">
                                    <i class="fas fa-trash-alt"></i> Clear
                                </button>
                            </div>
                            <div id="activityLog" style="max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 11px; background: #f8f9fa; padding: 10px; border-radius: 4px;">
                                <!-- Log entries will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .log-entry {
        padding: 5px 10px;
        border-bottom: 1px solid #f0f0f0;
    }
    .log-entry:hover {
        background: #f8f9fa;
    }
    .log-time {
        color: #6c757d;
        margin-right: 8px;
    }
    .log-info { color: #0d6efd; }
    .log-success { color: #198754; }
    .log-error { color: #dc3545; }
    .log-warning { color: #ffc107; }

    #videoOverlay.hidden {
        display: none !important;
    }

    /* Fullscreen video styling */
    #videoContainer:fullscreen {
        width: 100vw !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
    }

    #videoContainer:-webkit-full-screen {
        width: 100vw !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
    }

    #videoContainer:-moz-full-screen {
        width: 100vw !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
    }

    #videoContainer:-ms-fullscreen {
        width: 100vw !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
    }

    #videoContainer:fullscreen video,
    #videoContainer:-webkit-full-screen video,
    #videoContainer:-moz-full-screen video,
    #videoContainer:-ms-fullscreen video {
        width: 100% !important;
        height: 100% !important;
        object-fit: contain;
    }

    /* Control buttons hover effect */
    #fullscreenBtn:hover,
    #muteBtn:hover {
        opacity: 1 !important;
    }
</style>
{% endblock %}

{% block scripts %}
<script>
// Auto-detect server URLs based on current hostname
function getServerUrls() {
    const hostname = window.location.hostname;
    const isLocal = hostname === 'localhost' || hostname === '127.0.0.1';

    if (isLocal) {
        return {
            apiUrl: 'http://localhost:5000',
            signalingUrl: 'ws://localhost:8765'
        };
    } else {
        // Remote access - use same hostname as dashboard
        const protocol = window.location.protocol === 'https:' ? 'https' : 'http';
        const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const apiUrl = `${protocol}://${hostname}:5000`;
        const signalingUrl = `${wsProtocol}://${hostname}:8765`;

        // Debug logging
        console.log(`ðŸŒ Remote access detected - Hostname: ${hostname}`);
        console.log(`ðŸ“¡ API URL: ${apiUrl}`);
        console.log(`ðŸ”Œ Signaling URL: ${signalingUrl}`);

        return { apiUrl, signalingUrl };
    }
}

// Configuration from template with auto-detection
const serverUrls = getServerUrls();
const CONFIG = {
    cameraId: '{{ camera_id }}',
    apiUrl: serverUrls.apiUrl,
    signalingUrl: serverUrls.signalingUrl,
    stunServers: (function() {
        // Start with STUN servers
        const servers = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ];

        // Add TURN server if configured (for external access with strict NAT/firewall)
        {% if turn_config and turn_config.url %}
        const turnUrl = '{{ turn_config.url }}';
        const turnUsername = '{{ turn_config.username }}';
        const turnPassword = '{{ turn_config.password }}';

        if (turnUrl && turnUsername && turnPassword) {
            servers.push({
                urls: turnUrl,
                username: turnUsername,
                credential: turnPassword
            });
            console.log('ðŸ”„ TURN server enabled:', turnUrl);
        }
        {% endif %}

        return servers;
    })(),
    // CRITICAL: Allow mDNS candidates for localhost Kurento connections
    filterMdns: false
};

// Global state
let webSocket = null;
let peerConnection = null;
let streamId = null;
let viewerId = null;
let statsInterval = null;
let streamAttached = false;  // Track if video stream has been attached
let pendingIceCandidates = [];  // Queue for ICE candidates that arrive before SDP answer
let remoteDescriptionSet = false;  // Track if we've set the remote description
let safariDummyStream = null;  // Safari/Firefox workaround: dummy stream for relay candidate gathering

// UI elements
const videoPlayer = document.getElementById('videoPlayer');
const videoOverlay = document.getElementById('videoOverlay');
const startStreamBtn = document.getElementById('startStreamBtn');
const stopStreamBtn = document.getElementById('stopStreamBtn');
const streamStatus = document.getElementById('streamStatus');
const activityLog = document.getElementById('activityLog');
const clearLogBtn = document.getElementById('clearLogBtn');

// Display elements
const displayCameraId = document.getElementById('displayCameraId');
const displayStreamId = document.getElementById('displayStreamId');
const displayConnectionStatus = document.getElementById('displayConnectionStatus');
const displayIceState = document.getElementById('displayIceState');
const viewerCount = document.getElementById('viewerCount');

// Stats elements
const statDuration = document.getElementById('statDuration');
const statKeepalives = document.getElementById('statKeepalives');
const statErrors = document.getElementById('statErrors');

// Initialize
displayCameraId.textContent = CONFIG.cameraId.substring(0, 8) + '...';

// Show config on page load for debugging
log(`ðŸ“ Hostname: ${window.location.hostname}`, 'info');
log(`ðŸ“¡ API: ${CONFIG.apiUrl}`, 'info');
log(`ðŸ”Œ WebSocket: ${CONFIG.signalingUrl}`, 'info');

// Event listeners
startStreamBtn.addEventListener('click', startStream);
stopStreamBtn.addEventListener('click', stopStream);
clearLogBtn.addEventListener('click', () => {
    activityLog.innerHTML = '';
    log('Log cleared', 'info');
});

// Mute/Unmute functionality
const muteBtn = document.getElementById('muteBtn');
let autoUnmuteAttempted = false;  // Track if we've tried auto-unmute

muteBtn.addEventListener('click', toggleMute);

function toggleMute() {
    if (videoPlayer.muted) {
        // Unmute
        videoPlayer.muted = false;
        muteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
        muteBtn.title = 'Mute Audio';
        log('ðŸ”Š Audio unmuted', 'success');
    } else {
        // Mute
        videoPlayer.muted = true;
        muteBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
        muteBtn.title = 'Unmute Audio';
        log('ðŸ”‡ Audio muted', 'info');
    }
}

// Fullscreen functionality
const fullscreenBtn = document.getElementById('fullscreenBtn');
const videoContainer = document.getElementById('videoContainer');

fullscreenBtn.addEventListener('click', toggleFullscreen);

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        // Enter fullscreen
        if (videoContainer.requestFullscreen) {
            videoContainer.requestFullscreen();
        } else if (videoContainer.webkitRequestFullscreen) {
            videoContainer.webkitRequestFullscreen();
        } else if (videoContainer.mozRequestFullScreen) {
            videoContainer.mozRequestFullScreen();
        } else if (videoContainer.msRequestFullscreen) {
            videoContainer.msRequestFullscreen();
        }
    } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
}

// Update fullscreen button icon
document.addEventListener('fullscreenchange', updateFullscreenButton);
document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
document.addEventListener('mozfullscreenchange', updateFullscreenButton);
document.addEventListener('MSFullscreenChange', updateFullscreenButton);

function updateFullscreenButton() {
    if (document.fullscreenElement) {
        fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
    } else {
        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
    }
}

// Start stream
async function startStream() {
    try {
        log('Starting stream...', 'info');
        updateStreamStatus('Connecting...', 'warning');
        startStreamBtn.disabled = true;

        // Step 1: Start stream via API
        const response = await fetch(`/api/livestream/streams/${CONFIG.cameraId}/start`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to start stream');
        }

        const streamInfo = await response.json();
        streamId = streamInfo.stream_id;
        displayStreamId.textContent = streamId.substring(0, 8) + '...';

        log(`âœ… Stream started: ${streamInfo.session_id}`, 'success');

        // Step 2: Connect signaling
        await connectSignaling();

        // Step 3: Setup WebRTC
        await setupWebRTC();

        stopStreamBtn.disabled = false;
        startStatsPolling();

    } catch (error) {
        log(`âŒ Error: ${error.message}`, 'error');
        updateStreamStatus('Error', 'danger');
        startStreamBtn.disabled = false;
        cleanup();
    }
}

// Stop stream
async function stopStream() {
    try {
        log('Stopping stream...', 'info');
        stopStreamBtn.disabled = true;

        if (webSocket && webSocket.readyState === WebSocket.OPEN) {
            webSocket.send(JSON.stringify({ type: 'stop' }));
        }

        await fetch(`/api/livestream/streams/${CONFIG.cameraId}/stop`, {
            method: 'POST'
        });

        log('âœ… Stream stopped', 'success');
    } catch (error) {
        log(`âš ï¸ Error stopping: ${error.message}`, 'warning');
    } finally {
        cleanup();
        updateStreamStatus('Stopped', 'secondary');
        startStreamBtn.disabled = false;
    }
}

// Clean stream setup (stop stream for all viewers and clean state)
function cleanStreamSetup() {
    if (!confirm(`Clean stream setup for this camera?\n\nThis will:\n- Stop the camera stream\n- Stop keepalive messages\n- Disconnect all viewers\n- Reset stream state`)) {
        return;
    }

    log('ðŸ§¹ Cleaning stream setup...', 'info');

    fetch(`/api/livestream/streams/${CONFIG.cameraId}/stop`, {
        method: 'POST'
    })
    .then(response => response.json())
    .then(result => {
        if (result.success || result.message) {
            const duration = result.duration_seconds ? ` (Duration: ${Math.floor(result.duration_seconds)}s)` : '';
            const keepalives = result.keepalive_stats ? `, Keepalives: ${result.keepalive_stats.keepalive_count}` : '';
            log(`âœ… Stream cleaned successfully!${duration}${keepalives}`, 'success');
            alert(`âœ… Stream setup cleaned successfully!${duration}${keepalives}`);

            // Cleanup local state
            cleanup();
            updateStreamStatus('Cleaned', 'secondary');
            startStreamBtn.disabled = false;
            stopStreamBtn.disabled = true;
        } else {
            log(`âš ï¸ ${result.error || 'Failed to clean setup'}`, 'warning');
            alert(`âš ï¸ ${result.error || 'Failed to clean setup'}`);
        }
    })
    .catch(error => {
        console.error('Clean setup failed:', error);
        log('âŒ Failed to clean stream setup', 'error');
        alert('âŒ Failed to clean stream setup. Check console for details.');
    });
}

// Connect to signaling server
function connectSignaling() {
    return new Promise((resolve, reject) => {
        log(`ðŸ”Œ Connecting to: ${CONFIG.signalingUrl}`, 'info');
        console.log(`ðŸ”Œ WebSocket URL: ${CONFIG.signalingUrl}`);

        webSocket = new WebSocket(CONFIG.signalingUrl);

        webSocket.onopen = () => {
            log('âœ… Signaling connected', 'success');
            updateConnectionStatus('Connected', 'success');
            resolve();
        };

        webSocket.onerror = (error) => {
            console.error('âŒ WebSocket error:', error);
            log(`âŒ WebSocket error - Check port 8765 is accessible`, 'error');
            reject(new Error('WebSocket connection failed'));
        };

        webSocket.onclose = () => {
            log('Signaling closed', 'info');
            updateConnectionStatus('Disconnected', 'secondary');
        };

        webSocket.onmessage = handleSignalingMessage;
    });
}

// Setup WebRTC
async function setupWebRTC() {
    peerConnection = new RTCPeerConnection({
        iceServers: CONFIG.stunServers
    });

    // Safari/Firefox Workaround: Add dummy local tracks to enable ICE candidate gathering
    // Safari and Firefox won't gather relay candidates (TURN) for receive-only connections without local tracks
    // Safari: Can remove tracks after connection - https://webrtchacks.com/guide-to-safari-webrtc/
    // Firefox: Must KEEP tracks active for TURN relay to work (removing them breaks ICE renegotiation)
    if (isSafari() || isFirefox()) {
        try {
            const browserName = isSafari() ? 'Safari' : 'Firefox';
            const browserEmoji = isSafari() ? 'ðŸŽ' : 'ðŸ¦Š';
            log(`${browserEmoji} ${browserName} detected - requesting media permissions for ICE gathering...`, 'info');
            safariDummyStream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});

            // Add dummy tracks to peer connection - needed for relay candidate gathering
            safariDummyStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, safariDummyStream);
            });

            log('âœ… Media permissions granted and dummy tracks added', 'success');
        } catch (error) {
            log(`âš ï¸ Could not get media permissions: ${error.message}`, 'warning');
            log('Note: This may prevent relay (TURN) candidates from being gathered', 'warning');
        }
    }

    // Debug: Log ICE server configuration (without credentials)
    const iceServersForLogging = CONFIG.stunServers.map(server => ({
        urls: server.urls,
        hasCredentials: !!(server.username && server.credential)
    }));
    console.log('ðŸ§Š RTCPeerConnection created with ICE servers:', JSON.stringify(iceServersForLogging, null, 2));

    peerConnection.ontrack = (event) => {
        const trackType = event.track.kind;
        log(`ðŸ“º Received ${trackType} track`, 'success');

        // Safari/Firefox cleanup: Different strategies for each browser
        if (safariDummyStream) {
            if (isSafari()) {
                // Safari: Can safely remove dummy tracks once connection is established
                log(`ðŸ§¹ Removing Safari dummy tracks (connection established)`, 'info');
                const senders = peerConnection.getSenders();
                senders.forEach(sender => {
                    if (sender.track && safariDummyStream.getTracks().includes(sender.track)) {
                        peerConnection.removeTrack(sender);
                    }
                });
                // Stop the dummy stream tracks
                safariDummyStream.getTracks().forEach(track => track.stop());
                safariDummyStream = null;
            } else if (isFirefox()) {
                // Firefox: KEEP dummy tracks active to maintain TURN relay candidates
                // Removing them causes ICE to fail during renegotiation
                // Just mute them to prevent audio feedback
                log(`ðŸ¦Š Firefox: Keeping dummy tracks active for TURN relay (muting to prevent feedback)`, 'info');
                safariDummyStream.getTracks().forEach(track => {
                    track.enabled = false;  // Mute track but keep it in peer connection
                });
            }
        }

        // Only attach stream once (ontrack fires for each track: audio and video)
        // Setting srcObject multiple times interrupts play() and causes errors
        if (!streamAttached) {
            streamAttached = true;
            videoPlayer.srcObject = event.streams[0];

            // Explicitly play the video (browsers may block autoplay)
            videoPlayer.play().catch(error => {
                log('âš ï¸ Autoplay blocked - click video to play', 'warning');
                console.error('Play error:', error);
            });

            // Auto-unmute once stream starts (for better UX)
            // This happens after autoplay succeeds, so audio should work
            if (!autoUnmuteAttempted) {
                autoUnmuteAttempted = true;
                setTimeout(() => {
                    if (videoPlayer.muted) {
                        videoPlayer.muted = false;
                        muteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                        muteBtn.title = 'Mute Audio';
                        log('ðŸ”Š Audio auto-unmuted (click mute button to disable)', 'success');
                    }
                }, 500);  // Small delay to ensure playback started
            }

            videoOverlay.classList.add('hidden');
            updateStreamStatus('Streaming', 'success');
        }
    };

    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            const candidate = event.candidate;
            if (CONFIG.filterMdns && candidate.address && candidate.address.endsWith('.local')) {
                return;
            }
            webSocket.send(JSON.stringify({
                type: 'onIceCandidate',
                candidate: {
                    candidate: candidate.candidate,
                    sdpMid: candidate.sdpMid,
                    sdpMLineIndex: candidate.sdpMLineIndex
                }
            }));
        }
    };

    peerConnection.oniceconnectionstatechange = () => {
        const state = peerConnection.iceConnectionState;
        displayIceState.textContent = state;
        displayIceState.className = `badge bg-${state === 'connected' ? 'success' : state === 'failed' ? 'danger' : 'warning'}`;

        if (state === 'failed' || state === 'disconnected') {
            log('âŒ ICE connection failed', 'error');
            updateStreamStatus('Connection Failed', 'danger');
        }
    };

    const offer = await peerConnection.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: true
    });

    await peerConnection.setLocalDescription(offer);

    webSocket.send(JSON.stringify({
        type: 'viewer',
        cameraId: CONFIG.cameraId,
        streamId: streamId,
        sdpOffer: offer.sdp
    }));
}

// Handle signaling messages
async function handleSignalingMessage(event) {
    const message = JSON.parse(event.data);

    switch (message.type) {
        case 'viewerResponse':
            viewerId = message.viewerId;
            log(`âœ… Viewer connected`, 'success');
            const answer = new RTCSessionDescription({
                type: 'answer',
                sdp: message.sdpAnswer
            });
            await peerConnection.setRemoteDescription(answer);
            remoteDescriptionSet = true;

            // Process any queued ICE candidates that arrived before the SDP answer
            log(`ðŸ“¦ Processing ${pendingIceCandidates.length} queued ICE candidates`, 'info');
            for (const queuedCandidate of pendingIceCandidates) {
                try {
                    await peerConnection.addIceCandidate(queuedCandidate);
                } catch (error) {
                    console.error('Error adding queued ICE candidate:', error);
                }
            }
            pendingIceCandidates = [];
            break;

        case 'iceCandidate':
            const candidate = new RTCIceCandidate(message.candidate);
            if (CONFIG.filterMdns && candidate.address && candidate.address.endsWith('.local')) {
                // Skip mDNS candidates if filtering is enabled
                break;
            }

            if (!remoteDescriptionSet) {
                // Queue candidate if remote description not set yet (local network race condition)
                log(`ðŸ“¥ Queuing ICE candidate (waiting for SDP answer)`, 'debug');
                pendingIceCandidates.push(candidate);
            } else {
                // Add candidate immediately if remote description is already set
                try {
                    await peerConnection.addIceCandidate(candidate);
                    log(`âœ… Added ICE candidate`, 'debug');
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }
            break;

        case 'error':
            log(`âŒ Server error: ${message.message}`, 'error');
            break;
    }
}

// Cleanup
function cleanup() {
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    if (webSocket) {
        webSocket.close();
        webSocket = null;
    }
    if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
    }

    // Safari/Firefox cleanup: Stop dummy stream if it still exists
    if (safariDummyStream) {
        log('ðŸ§¹ Cleaning up browser dummy tracks', 'info');
        safariDummyStream.getTracks().forEach(track => track.stop());
        safariDummyStream = null;
    }

    videoPlayer.srcObject = null;
    videoOverlay.classList.remove('hidden');
    streamId = null;
    streamAttached = false;  // Reset flag for next stream
    remoteDescriptionSet = false;  // Reset for next stream
    pendingIceCandidates = [];  // Clear queue
    autoUnmuteAttempted = false;  // Reset auto-unmute for next stream

    // Reset mute button to muted state
    videoPlayer.muted = true;
    muteBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
    muteBtn.title = 'Unmute Audio';

    displayStreamId.textContent = '-';
    displayIceState.textContent = '-';
    displayIceState.className = 'badge bg-secondary';
    updateConnectionStatus('-', 'secondary');
}

// Stats polling
function startStatsPolling() {
    statsInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/livestream/streams/${CONFIG.cameraId}`);
            if (response.ok) {
                const data = await response.json();
                const stream = data.stream;

                if (stream.duration_seconds) {
                    statDuration.textContent = formatDuration(stream.duration_seconds);
                }

                if (stream.keepalive_stats) {
                    statKeepalives.textContent = stream.keepalive_stats.keepalive_count || 0;
                    statErrors.textContent = stream.keepalive_stats.error_count || 0;
                }

                viewerCount.textContent = data.viewer_count || 0;
            }
        } catch (error) {
            console.error('Stats polling error:', error);
        }
    }, 2000);
}

// Helpers
function isSafari() {
    // Detect Safari browser (including iOS Safari)
    const ua = navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1 && ua.indexOf('chromium') === -1;
}

function isFirefox() {
    // Detect Firefox browser
    const ua = navigator.userAgent.toLowerCase();
    return ua.indexOf('firefox') !== -1;
}

function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
        return `${hours}h ${minutes}m ${secs}s`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs}s`;
    } else {
        return `${secs}s`;
    }
}

function updateStreamStatus(text, type) {
    streamStatus.textContent = text;
    streamStatus.className = `badge bg-${type}`;
}

function updateConnectionStatus(text, type) {
    displayConnectionStatus.textContent = text;
    displayConnectionStatus.className = `badge bg-${type}`;
}

function log(message, level = 'info') {
    const time = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.className = `log-entry log-${level}`;
    entry.innerHTML = `<span class="log-time">${time}</span>${message}`;

    activityLog.insertBefore(entry, activityLog.firstChild);

    while (activityLog.children.length > 100) {
        activityLog.removeChild(activityLog.lastChild);
    }
}
</script>
{% endblock %}
